We began our implementation by creating a series of tests for our parser. We decided to use the original Picobot syntax as our external DSL. We ran in to a lot of trouble while implementing our parser, as we could not quite figure out how to correctly pattern match terminal strings. We spent a lot of time implementing a few basic components of our parser because we did not know that the PackratParser automatically ignores whitespace. 

In implementing our parser and interpreter, we did our best to adhere as closely as possible to Picobot's original syntax. We really wanted to see what it must have been like for the original Picobot developers to implement the software, and although we ran in to a lot of issues because of this decision, it is not something we regret. 

After completely implementing a parser and corresponding tests for our ideal grammar, we moved on to mapping our internal representation (AST) to semantics in the given picolib module. During this implementation, we ran in to several roadblocks when trying to map members of our own internal representation to similar representations within picolib. For instance, we did not know how to convert our internally represented "North" direction to the corresponding direction in picolib. We spent a lot of time on errors like these but were able to eventually move past them with help from Google and Prof Ben. 

We implemented a series of tests for our interpreter, and we slowly expanded the interpreter to output an executable Picobot object. We implemented almost every intermediate interpreter along the way: one that outputted a single rule, one that outputted a list of rules, and finally one that outputted a tuple of a Maze and a list of rules. Because we kept having such difficulties with the assignments, we thought that such an incremental approach would be best. This turned out to be a good decision, for it allowed us to easily modularize our code. By the end of our work on the parser and interpreter, we successfully parsed and interpreted an entire Picobot program (in the form of a text file) which immediately executed in a maze. Along the way, we only had to make one small change to Picobot's original grammar. Because we were not implementing our external DSL in a browser, as is done in the introductory computer science course at Mudd, we changed the original Picobot syntax to include the name of a maze file at the top of the program. 

In summary, we were quite successful in piecing together an end-to-end parser and interpreter for Picobot which is extremely similar to the program's original syntax. On a scale of 1-10, we feel that we changed our original syntax on the level of 2.

At the end of our implementation, we added error checking to our parser. We thought about implementing further error-checking in our interpreter to ensure that there were no references to undefined states. We planned to implement this by having a helper function check all of the states to make sure that all the states on the right hand side appeared in the left hand side (i.e. you never went to a state that was not defined) and throwing/catching a custom exception with a message but we did not have enough time to do this. 